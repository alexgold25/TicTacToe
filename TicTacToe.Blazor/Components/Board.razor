@implements IDisposable
@inject TicTacToe.Blazor.Services.GameService S


<div class="top">
    <button class="btn" @onclick="S.NewGame">New Game</button>

    <button class="btn" @onclick="ToggleMode">
        @(S.PlayVsRandom ? "Vs Computer" : "Vs Human")
    </button>

    <label class="toggle">
        <input type="checkbox" @bind="S.SoundEnabled" />
        <span>Sound</span>
    </label>

    <div class="stats">
        <span>X: @S.XWins</span>
        <span>O: @S.OWins</span>
        <span>Draws: @S.Draws</span>
    </div>
</div>

<div class="board">
    @using TicTacToe

    @for (int i = 0; i < 9; i++)
    {
        var idx = i;  // локальная копия для лямбды
                      <button @key="idx"
                              type="button"
                              class="cell @(S.Highlight[idx] ? "win" : "")"
                              disabled="@S.Game.IsGameOver"
                              @onclick="() => S.Put(idx)">
            @(S.Game.Board[idx] == Cell.X ? "X" :
                    S.Game.Board[idx] == Cell.O ? "O" : "")
    </button>
        }


    @if (S.WinningCombo is not null)
    {

            <svg class="win-line" viewBox="0 0 300 300" preserveAspectRatio="none">
                @{
                    var (x1, y1, x2, y2) = LineEndpoints(S.WinningCombo!);
                }
            <!-- мягкое свечение -->
            <line x1="@x1" y1="@y1" x2="@x2" y2="@y2"
                  stroke="var(--accent, #3af)"
                  stroke-opacity="0.35"
                  stroke-width="18"
                  stroke-linecap="round" />
            <!-- основная линия -->
            <line x1="@x1" y1="@y1" x2="@x2" y2="@y2"
                  stroke="#bfe6ff"
                  stroke-width="12"
                  stroke-linecap="round" />
            </svg>


    }

</div>

@code {
    protected override void OnInitialized()
    {
        S.NewGame();                 // сначала состояние
        S.Changed += StateHasChanged; // затем подписка
    }
    public void Dispose() => S.Changed -= StateHasChanged;

    private void ToggleMode()
    {
        S.PlayVsRandom = !S.PlayVsRandom;
        S.NewGame();
    }

    private static (int x1, int y1, int x2, int y2) LineEndpoints(int[] combo)
    {
        static (int x, int y) Center(int idx)
        {
            int col = idx % 3, row = idx / 3;
            return (col * 100 + 50, row * 100 + 50);
        }

        var (xa, ya) = Center(combo[0]);
        var (xb, yb) = Center(combo[2]);

        double dx = xb - xa, dy = yb - ya;
        double len = Math.Sqrt(dx * dx + dy * dy);
        if (len == 0) len = 1;
        double ux = dx / len, uy = dy / len;
        int pad = 20;

        int x1 = (int)Math.Round(xa - ux * pad);
        int y1 = (int)Math.Round(ya - uy * pad);
        int x2 = (int)Math.Round(xb + ux * pad);
        int y2 = (int)Math.Round(yb + uy * pad);

        return (x1, y1, x2, y2);
    }

    bool CanClick(int i)
    {
        // Кликать можно, только если игра не закончена и клетка пустая
        return !S.Game.IsGameOver && (S.View[i] ?? string.Empty) == string.Empty;
    }

}
